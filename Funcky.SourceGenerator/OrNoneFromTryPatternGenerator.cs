using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Funcky.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class OrNoneFromTryPatternGenerator : IIncrementalGenerator
{
    private const string AttributeFullName = "Funcky.Internal.OrNoneFromTryPatternAttribute";
    private const string StringSyntaxAttributeFullName = "System.Diagnostics.CodeAnalysis.StringSyntaxAttribute";
    private static readonly IEnumerable<string> GeneratedFileHeadersSource = ImmutableList.Create("// <auto-generated/>", "#nullable enable", string.Empty);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(RegisterOrNoneAttribute);
        context.RegisterSourceOutput(GetOrNonePartialMethods(context), RegisterOrNonePartials);
    }

    private static void RegisterOrNonePartials(SourceProductionContext context, ImmutableArray<MethodPartial> partialMethods)
        => _ = partialMethods
            .GroupBy(partialMethod => partialMethod.SourceTree.FilePath)
            .Aggregate(context, CreateSourceByClass);

    private static SourceProductionContext CreateSourceByClass(SourceProductionContext context, IGrouping<string, MethodPartial> methodByClass)
    {
        var syntaxTree = OrNoneFromTryPatternPartial.GetSyntaxTree(methodByClass.First().NamespaceName, methodByClass.First().ClassName, methodByClass.SelectMany(m => m.Methods));

        context.AddSource($"{Path.GetFileName(methodByClass.Key)}.g.cs", string.Join("\n", GeneratedFileHeadersSource) + "\n" + syntaxTree.NormalizeWhitespace().ToFullString());

        return context;
    }

    private static IncrementalValueProvider<ImmutableArray<MethodPartial>> GetOrNonePartialMethods(IncrementalGeneratorInitializationContext context)
        => context.SyntaxProvider.ForAttributeWithMetadataName(AttributeFullName, IsSyntaxTargetForGeneration, GetSemanticTargetForGeneration)
            .Combine(context.CompilationProvider)
            .Select((state, _) => ToMethodPartial(state.Left, state.Right))
            .Collect();

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node, CancellationToken cancellationToken)
        => node is ClassDeclarationSyntax { AttributeLists: [_, ..] };

    private static SemanticTarget GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        var node = (ClassDeclarationSyntax)context.TargetNode;
        return new SemanticTarget(node, context.Attributes.Select(ParseAttribute).ToImmutableArray());
    }

    private static ParsedAttribute ParseAttribute(AttributeData attribute)
        => attribute.ConstructorArguments is [{ Value: INamedTypeSymbol type }, { Value: string methodName }, ..]
            ? new ParsedAttribute(type, methodName)
            : throw new InvalidOperationException("Invalid attribute: expected a named type and a method name");

    private static MethodPartial ToMethodPartial(SemanticTarget semanticTarget, Compilation compilation)
        => new(
            NamespaceName: GetNamespaceName(semanticTarget.ClassDeclarationSyntax, compilation),
            ClassName: semanticTarget.ClassDeclarationSyntax.Identifier.ToString(),
            Methods: GenerateMethods(semanticTarget).ToImmutableArray(),
            SourceTree: semanticTarget.ClassDeclarationSyntax.SyntaxTree);

    private static IEnumerable<MethodDeclarationSyntax> GenerateMethods(SemanticTarget semanticTarget)
        => (from attribute in semanticTarget.Attributes
            from method in attribute.Type.GetMembers().OfType<IMethodSymbol>()
            where method.Name == attribute.MethodName
            select GenerateOrNoneMethod(attribute.Type, method));

    private static MethodDeclarationSyntax GenerateOrNoneMethod(ITypeSymbol type, IMethodSymbol method)
        => MethodDeclaration(
            ParseTypeName($"Funcky.Monads.Option<{type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>"),
            GetMethodName(type, method))
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword)))
            .WithParameterList(ParameterList(SeparatedList(method.Parameters.Where(p => p.RefKind is RefKind.None).Select(GenerateParameter))))
            .WithExpressionBody(ArrowExpressionClause(GenerateOrNoneImplementation(type, method)))
            .WithAttributeLists(SingletonList(AttributeList(SingletonSeparatedList(Attribute(IdentifierName("global::System.Diagnostics.Contracts.Pure"))))))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));

    private static ExpressionSyntax GenerateOrNoneImplementation(ITypeSymbol type, IMethodSymbol method)
        => ConditionalExpression(
            condition: InvocationExpression(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    ParseTypeName(method.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)),
                    IdentifierName(method.Name)),
                GenerateTryMethodArgumentList(method)),
            whenTrue: IdentifierName(method.Parameters.Single(IsOutParameter).Name),
            whenFalse: DefaultExpression(ParseTypeName($"Funcky.Monads.Option<{type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>")));

    private static ArgumentListSyntax GenerateTryMethodArgumentList(IMethodSymbol method)
        => ArgumentList(SeparatedList(method.Parameters.Select(GenerateTryMethodArgument)));

    private static ArgumentSyntax GenerateTryMethodArgument(IParameterSymbol parameter, int index)
        => IsOutParameter(parameter)
            ? GenerateOutVarArgument(Identifier(GetParameterName(parameter, index)))
            : Argument(IdentifierName(GetParameterName(parameter, index)));

    private static bool IsOutParameter(IParameterSymbol parameter) => parameter.RefKind is RefKind.Out;

    private static ArgumentSyntax GenerateOutVarArgument(SyntaxToken identifier)
        => Argument(
            nameColon: null,
            Token(SyntaxKind.OutKeyword),
            DeclarationExpression(
                IdentifierName(VarKeyword()),
                SingleVariableDesignation(identifier)));

    private static SyntaxToken VarKeyword()
        => Identifier(TriviaList(), SyntaxKind.VarKeyword, "var", "var", TriviaList());

    private static ParameterSyntax GenerateParameter(IParameterSymbol parameter, int index)
        => Parameter(Identifier(GetParameterName(parameter, index)))
            .WithModifiers(index == 0 ? TokenList(Token(SyntaxKind.ThisKeyword)) : TokenList())
            .WithType(GenerateTypeSyntax(parameter.Type))
            .WithDefault(GetParameterDefaultValue(parameter))
            .WithAttributeLists(GenerateParameterAttributeLists(parameter));

    private static SyntaxList<AttributeListSyntax> GenerateParameterAttributeLists(IParameterSymbol parameter)
        => GenerateParameterAttributes(parameter).ToImmutableArray() is [_, ..] attributes
            ? SingletonList(AttributeList(SeparatedList(attributes)))
            : List<AttributeListSyntax>();

    private static IEnumerable<AttributeSyntax> GenerateParameterAttributes(IParameterSymbol parameter)
        => parameter.GetAttributes().Where(ShouldCopyParameterAttribute).Select(GenerateParameterAttribute);

    private static AttributeSyntax GenerateParameterAttribute(AttributeData originalAttribute)
        => Attribute(
            ParseName(GenerateTypeSyntax(originalAttribute.AttributeClass!).ToString()),
            AttributeArgumentList(SeparatedList(originalAttribute.ConstructorArguments.Select(GenerateAttributeArgument))));

    private static AttributeArgumentSyntax GenerateAttributeArgument(TypedConstant argumentValue)
        => AttributeArgument(ParseExpression(argumentValue.ToCSharpString()));

    private static bool ShouldCopyParameterAttribute(AttributeData originalAttribute)
        => originalAttribute.AttributeClass?.ToDisplayString() == StringSyntaxAttributeFullName;

    private static TypeSyntax GenerateTypeSyntax(ITypeSymbol type)
    {
        var parsedType = ParseTypeName(type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier)));
        return type.NullableAnnotation is not NullableAnnotation.None
            ? parsedType
            : parsedType
                .WithLeadingTrivia(Trivia(NullableDirectiveTrivia(Token(SyntaxKind.DisableKeyword), true)))
                .WithTrailingTrivia(Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword), true)));
    }

    private static string GetNamespaceName(SyntaxNode methodDeclaration, Compilation compilation)
        => compilation.GetSemanticModel(methodDeclaration.SyntaxTree)
            .GetDeclaredSymbol(methodDeclaration)?
            .ContainingNamespace
            .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted))
                ?? throw new InvalidOperationException("Unable to detect containing namespace");

    private static string GetMethodName(ITypeSymbol type, IMethodSymbol method)
    {
        const string tryPrefix = "Try";
        const string orNoneSuffix = "OrNone";
        return method.Name.StartsWith(tryPrefix)
            ? $"{method.Name.Substring(tryPrefix.Length)}{type.Name}{orNoneSuffix}"
            : $"{method.Name}{type.Name}{orNoneSuffix}";
    }

    private static string GetParameterName(ISymbol parameter, int index)
        => index is 0
            ? "candidate"
            : parameter.Name;

    private static EqualsValueClauseSyntax? GetParameterDefaultValue(IParameterSymbol parameter)
        => parameter.HasExplicitDefaultValue
            ? EqualsValueClause(GetLiteralForConstantValue(parameter.ExplicitDefaultValue, parameter.Type))
            : null;

    private static ExpressionSyntax GetLiteralForConstantValue(object? value, ITypeSymbol type)
        => value switch
        {
            null => LiteralExpression(SyntaxKind.NullLiteralExpression),
            _ => throw new NotSupportedException($"unsupported constant: {value} ({type})"),
        };

    private static void RegisterOrNoneAttribute(IncrementalGeneratorPostInitializationContext context)
        => context.AddSource("OrNoneFromTryPatternAttribute.g.cs", CodeSnippets.OrNoneFromTryPatternAttribute);

    private sealed record SemanticTarget(ClassDeclarationSyntax ClassDeclarationSyntax, ImmutableArray<ParsedAttribute> Attributes);

    private sealed record ParsedAttribute(INamedTypeSymbol Type, string MethodName);
}
